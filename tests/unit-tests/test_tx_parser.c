#include <stdarg.h>
#include <stddef.h>
#include <setjmp.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>

#include <cmocka.h>

#include "transaction/errors.h"
#include "transaction/deserialise.h"
#include "transaction/types.h"

static void test_tx_sample_serialization(void **state) {
    (void) state;

    transaction_t tx;
    // clang-format off
    uint8_t raw_tx[] = {
        // startbyte (1)
        0xff,
        // Version (1)
        0x03,
        // Network (1)
        0x3f,
        // typeGroup (4)
        0x01, 0x00, 0x00, 0x00,
        // Type (2)
        0x06, 0x00,
        // nonce (8)
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        // PublicKey (33)
        0x03, 0x4d, 0xa0, 0x06, 0xf9, 0x58, 0xbe, 0xba,
        0x78, 0xec, 0x54, 0x44, 0x3d, 0xf4, 0xa3, 0xf5,
        0x22, 0x37, 0x25, 0x3f, 0x7a, 0xe8, 0xcb, 0xdb,
        0x17, 0xdc, 0xcf, 0x3f, 0xea, 0xa5, 0x7f, 0x31,
        0x26,
        // fee (8)
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        // memo length
        0xf1,
        // memo
        0x54, 0x68, 0x65, 0x20, 0x54, 0x68, 0x65, 0x6f,
        0x72, 0x79, 0x20, 0x6f, 0x66, 0x20, 0x47, 0x72,
        0x6f, 0x75, 0x70, 0x73, 0x20, 0x69, 0x73, 0x20,
        0x61, 0x20, 0x62, 0x72, 0x61, 0x6e, 0x63, 0x68,
        0x20, 0x6f, 0x66, 0x20, 0x6d, 0x61, 0x74, 0x68,
        0x65, 0x6d, 0x61, 0x74, 0x69, 0x63, 0x73, 0x20,
        0x69, 0x6e, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68,
        0x20, 0x6f, 0x6e, 0x65, 0x20, 0x64, 0x6f, 0x65,
        0x73, 0x20, 0x73, 0x6f, 0x6d, 0x65, 0x74, 0x68,
        0x69, 0x6e, 0x67, 0x20, 0x74, 0x6f, 0x20, 0x73,
        0x6f, 0x6d, 0x65, 0x74, 0x68, 0x69, 0x6e, 0x67,
        0x20, 0x61, 0x6e, 0x64, 0x20, 0x74, 0x68, 0x65,
        0x6e, 0x20, 0x63, 0x6f, 0x6d, 0x70, 0x61, 0x72,
        0x65, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72,
        0x65, 0x73, 0x75, 0x6c, 0x74, 0x20, 0x77, 0x69,
        0x74, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72,
        0x65, 0x73, 0x75, 0x6c, 0x74, 0x20, 0x6f, 0x62,
        0x74, 0x61, 0x69, 0x6e, 0x65, 0x64, 0x20, 0x66,
        0x72, 0x6f, 0x6d, 0x20, 0x64, 0x6f, 0x69, 0x6e,
        0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61,
        0x6d, 0x65, 0x20, 0x74, 0x68, 0x69, 0x6e, 0x67,
        0x20, 0x74, 0x6f, 0x20, 0x73, 0x6f, 0x6d, 0x65,
        0x74, 0x68, 0x69, 0x6e, 0x67, 0x20, 0x65, 0x6c,
        0x73, 0x65, 0x2c, 0x20, 0x6f, 0x72, 0x20, 0x73,
        0x6f, 0x6d, 0x65, 0x74, 0x68, 0x69, 0x6e, 0x67,
        0x20, 0x65, 0x6c, 0x73, 0x65, 0x20, 0x74, 0x6f,
        0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6d,
        0x65, 0x20, 0x74, 0x68, 0x69, 0x6e, 0x67, 0x2e,
        0x20, 0x4e, 0x65, 0x77, 0x6d, 0x61, 0x6e, 0x2c,
        0x20, 0x4a, 0x61, 0x6d, 0x65, 0x73, 0x20, 0x52,
        0x2e,
         // length (2)
        0x01, 0x00,
        // amount 1 (8)
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        // RecipientId 1 (21)
        0x3f, 0xc9, 0x13, 0x27, 0xb9, 0x17, 0xbf, 0x2b,
        0x46, 0x4e, 0x9b, 0x8f, 0x1a, 0xcf, 0x05, 0x88,
        0xf4, 0xcb, 0x6e, 0x7b, 0xb3,
    };

    uint8_t wrong_common[] = {
        // startbyte (1)
        0xfe, // Wrong version
        // Version (1)
        0x03,
        // Network (1)
        0x3f,
        // typeGroup (4)
        0x01, 0x00, 0x00, 0x00,
        // Type (2)
        0x06, 0x00,
        // nonce (8)
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        // PublicKey (33)
        0x03, 0x4d, 0xa0, 0x06, 0xf9, 0x58, 0xbe, 0xba,
        0x78, 0xec, 0x54, 0x44, 0x3d, 0xf4, 0xa3, 0xf5,
        0x22, 0x37, 0x25, 0x3f, 0x7a, 0xe8, 0xcb, 0xdb,
        0x17, 0xdc, 0xcf, 0x3f, 0xea, 0xa5, 0x7f, 0x31,
        0x26,
        // fee (8)
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        // memo length
        0xf1,
        // memo
        0x54, 0x68, 0x65, 0x20, 0x54, 0x68, 0x65, 0x6f,
        0x72, 0x79, 0x20, 0x6f, 0x66, 0x20, 0x47, 0x72,
        0x6f, 0x75, 0x70, 0x73, 0x20, 0x69, 0x73, 0x20,
        0x61, 0x20, 0x62, 0x72, 0x61, 0x6e, 0x63, 0x68,
        0x20, 0x6f, 0x66, 0x20, 0x6d, 0x61, 0x74, 0x68,
        0x65, 0x6d, 0x61, 0x74, 0x69, 0x63, 0x73, 0x20,
        0x69, 0x6e, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68,
        0x20, 0x6f, 0x6e, 0x65, 0x20, 0x64, 0x6f, 0x65,
        0x73, 0x20, 0x73, 0x6f, 0x6d, 0x65, 0x74, 0x68,
        0x69, 0x6e, 0x67, 0x20, 0x74, 0x6f, 0x20, 0x73,
        0x6f, 0x6d, 0x65, 0x74, 0x68, 0x69, 0x6e, 0x67,
        0x20, 0x61, 0x6e, 0x64, 0x20, 0x74, 0x68, 0x65,
        0x6e, 0x20, 0x63, 0x6f, 0x6d, 0x70, 0x61, 0x72,
        0x65, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72,
        0x65, 0x73, 0x75, 0x6c, 0x74, 0x20, 0x77, 0x69,
        0x74, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72,
        0x65, 0x73, 0x75, 0x6c, 0x74, 0x20, 0x6f, 0x62,
        0x74, 0x61, 0x69, 0x6e, 0x65, 0x64, 0x20, 0x66,
        0x72, 0x6f, 0x6d, 0x20, 0x64, 0x6f, 0x69, 0x6e,
        0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61,
        0x6d, 0x65, 0x20, 0x74, 0x68, 0x69, 0x6e, 0x67,
        0x20, 0x74, 0x6f, 0x20, 0x73, 0x6f, 0x6d, 0x65,
        0x74, 0x68, 0x69, 0x6e, 0x67, 0x20, 0x65, 0x6c,
        0x73, 0x65, 0x2c, 0x20, 0x6f, 0x72, 0x20, 0x73,
        0x6f, 0x6d, 0x65, 0x74, 0x68, 0x69, 0x6e, 0x67,
        0x20, 0x65, 0x6c, 0x73, 0x65, 0x20, 0x74, 0x6f,
        0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6d,
        0x65, 0x20, 0x74, 0x68, 0x69, 0x6e, 0x67, 0x2e,
        0x20, 0x4e, 0x65, 0x77, 0x6d, 0x61, 0x6e, 0x2c,
        0x20, 0x4a, 0x61, 0x6d, 0x65, 0x73, 0x20, 0x52,
        0x2e,
         // length (2)
        0x01, 0x00,
        // amount 1 (8)
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        // RecipientId 1 (21)
        0x3f, 0xc9, 0x13, 0x27, 0xb9, 0x17, 0xbf, 0x2b,
        0x46, 0x4e, 0x9b, 0x8f, 0x1a, 0xcf, 0x05, 0x88,
        0xf4, 0xcb, 0x6e, 0x7b, 0xb3,
    };

    buffer_t buf1 = {.ptr = raw_tx, .size = sizeof(raw_tx), .offset = 0};
    buffer_t buf2 = {.ptr = wrong_common, .size = sizeof(wrong_common), .offset = 0};

    parser_status_e status = transaction_deserialise(&buf1, &tx);

    assert_int_equal(status, PARSING_OK);

    memset(&status, 0, sizeof(status));

    status = transaction_deserialise(&buf2, &tx);

    assert_int_equal(status, STARTING_BYTE_PARSING_ERROR);

}

static void test_tx_common_serialization(void **state) {
    (void) state;

    transaction_t tx;
    // clang-format off
    uint8_t raw_tx[] = {
        // startbyte (1)
        0xff,
        // Version (1)
        0x03,
        // Network (1)
        0x3f,
        // typeGroup (4)
        0x01, 0x00, 0x00, 0x00,
        // Type (2)
        0x00, 0x00,
        // nonce (8)
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        // PublicKey (33)
        0x03, 0x4d, 0xa0, 0x06, 0xf9, 0x58, 0xbe, 0xba,
        0x78, 0xec, 0x54, 0x44, 0x3d, 0xf4, 0xa3, 0xf5,
        0x22, 0x37, 0x25, 0x3f, 0x7a, 0xe8, 0xcb, 0xdb,
        0x17, 0xdc, 0xcf, 0x3f, 0xea, 0xa5, 0x7f, 0x31,
        0x26,
        // fee (8)
        0x01, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        // memo length
        0xf1,
        // memo
        0x54, 0x68, 0x65, 0x20, 0x54, 0x68, 0x65, 0x6f,
        0x72, 0x79, 0x20, 0x6f, 0x66, 0x20, 0x47, 0x72,
        0x6f, 0x75, 0x70, 0x73, 0x20, 0x69, 0x73, 0x20,
        0x61, 0x20, 0x62, 0x72, 0x61, 0x6e, 0x63, 0x68,
        0x20, 0x6f, 0x66, 0x20, 0x6d, 0x61, 0x74, 0x68,
        0x65, 0x6d, 0x61, 0x74, 0x69, 0x63, 0x73, 0x20,
        0x69, 0x6e, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68,
        0x20, 0x6f, 0x6e, 0x65, 0x20, 0x64, 0x6f, 0x65,
        0x73, 0x20, 0x73, 0x6f, 0x6d, 0x65, 0x74, 0x68,
        0x69, 0x6e, 0x67, 0x20, 0x74, 0x6f, 0x20, 0x73,
        0x6f, 0x6d, 0x65, 0x74, 0x68, 0x69, 0x6e, 0x67,
        0x20, 0x61, 0x6e, 0x64, 0x20, 0x74, 0x68, 0x65,
        0x6e, 0x20, 0x63, 0x6f, 0x6d, 0x70, 0x61, 0x72,
        0x65, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72,
        0x65, 0x73, 0x75, 0x6c, 0x74, 0x20, 0x77, 0x69,
        0x74, 0x68, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72,
        0x65, 0x73, 0x75, 0x6c, 0x74, 0x20, 0x6f, 0x62,
        0x74, 0x61, 0x69, 0x6e, 0x65, 0x64, 0x20, 0x66,
        0x72, 0x6f, 0x6d, 0x20, 0x64, 0x6f, 0x69, 0x6e,
        0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61,
        0x6d, 0x65, 0x20, 0x74, 0x68, 0x69, 0x6e, 0x67,
        0x20, 0x74, 0x6f, 0x20, 0x73, 0x6f, 0x6d, 0x65,
        0x74, 0x68, 0x69, 0x6e, 0x67, 0x20, 0x65, 0x6c,
        0x73, 0x65, 0x2c, 0x20, 0x6f, 0x72, 0x20, 0x73,
        0x6f, 0x6d, 0x65, 0x74, 0x68, 0x69, 0x6e, 0x67,
        0x20, 0x65, 0x6c, 0x73, 0x65, 0x20, 0x74, 0x6f,
        0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6d,
        0x65, 0x20, 0x74, 0x68, 0x69, 0x6e, 0x67, 0x2e,
        0x20, 0x4e, 0x65, 0x77, 0x6d, 0x61, 0x6e, 0x2c,
        0x20, 0x4a, 0x61, 0x6d, 0x65, 0x73, 0x20, 0x52,
        0x2e
    };

    uint8_t *pkey_ptr = (uint8_t *) raw_tx + 17;
    uint8_t *memo_ptr = (uint8_t *) raw_tx + 59;

    uint8_t wrong_start_byte[] = {
        // startbyte (1)
        0xfe,
        // Version (1)
        0x03,
        // Network (1)
        0x3f,
        // typeGroup (4)
        0x01, 0x00, 0x00, 0x00,
        // Type (2)
        0x00, 0x00,
        // nonce (8)
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        // PublicKey (33)
        0x03, 0x4d, 0xa0, 0x06, 0xf9, 0x58, 0xbe, 0xba,
        0x78, 0xec, 0x54, 0x44, 0x3d, 0xf4, 0xa3, 0xf5,
        0x22, 0x37, 0x25, 0x3f, 0x7a, 0xe8, 0xcb, 0xdb,
        0x17, 0xdc, 0xcf, 0x3f, 0xea, 0xa5, 0x7f, 0x31,
        0x26,
        // fee (8)
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        // memo length
        0x00
    };

    uint8_t wrong_version[] = {
        // startbyte (1)
        0xff,
        // Version (1)
        0x02,
        // Network (1)
        0x3f,
        // typeGroup (4)
        0x01, 0x00, 0x00, 0x00,
        // Type (2)
        0x00, 0x00,
        // nonce (8)
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        // PublicKey (33)
        0x03, 0x4d, 0xa0, 0x06, 0xf9, 0x58, 0xbe, 0xba,
        0x78, 0xec, 0x54, 0x44, 0x3d, 0xf4, 0xa3, 0xf5,
        0x22, 0x37, 0x25, 0x3f, 0x7a, 0xe8, 0xcb, 0xdb,
        0x17, 0xdc, 0xcf, 0x3f, 0xea, 0xa5, 0x7f, 0x31,
        0x26,
        // fee (8)
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        // memo length
        0x00
    };

    uint8_t wrong_network[] = {
        // startbyte (1)
        0xff,
        // Version (1)
        0x03,
        // Network (1)
        0x3e,
        // typeGroup (4)
        0x01, 0x00, 0x00, 0x00,
        // Type (2)
        0x00, 0x00,
        // nonce (8)
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        // PublicKey (33)
        0x03, 0x4d, 0xa0, 0x06, 0xf9, 0x58, 0xbe, 0xba,
        0x78, 0xec, 0x54, 0x44, 0x3d, 0xf4, 0xa3, 0xf5,
        0x22, 0x37, 0x25, 0x3f, 0x7a, 0xe8, 0xcb, 0xdb,
        0x17, 0xdc, 0xcf, 0x3f, 0xea, 0xa5, 0x7f, 0x31,
        0x26,
        // fee (8)
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        // memo length
        0x00
    };

    uint8_t wrong_memo_length[] = {
        // startbyte (1)
        0xff,
        // Version (1)
        0x03,
        // Network (1)
        0x3f,
        // typeGroup (4)
        0x01, 0x00, 0x00, 0x00,
        // Type (2)
        0x00, 0x00,
        // nonce (8)
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        // PublicKey (33)
        0x03, 0x4d, 0xa0, 0x06, 0xf9, 0x58, 0xbe, 0xba,
        0x78, 0xec, 0x54, 0x44, 0x3d, 0xf4, 0xa3, 0xf5,
        0x22, 0x37, 0x25, 0x3f, 0x7a, 0xe8, 0xcb, 0xdb,
        0x17, 0xdc, 0xcf, 0x3f, 0xea, 0xa5, 0x7f, 0x31,
        0x26,
        // fee (8)
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        // memo length
        0x03,
        // memo
        0x63, 0x62
    };

    uint8_t wrong_memo_encoding[] = {
        // startbyte (1)
        0xff,
        // Version (1)
        0x03,
        // Network (1)
        0x3f,
        // typeGroup (4)
        0x01, 0x00, 0x00, 0x00,
        // Type (2)
        0x00, 0x00,
        // nonce (8)
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        // PublicKey (33)
        0x03, 0x4d, 0xa0, 0x06, 0xf9, 0x58, 0xbe, 0xba,
        0x78, 0xec, 0x54, 0x44, 0x3d, 0xf4, 0xa3, 0xf5,
        0x22, 0x37, 0x25, 0x3f, 0x7a, 0xe8, 0xcb, 0xdb,
        0x17, 0xdc, 0xcf, 0x3f, 0xea, 0xa5, 0x7f, 0x31,
        0x26,
        // fee (8)
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        // memo length
        0x02,
        // memo
        0x63, 0x0a
    };

    for (uint16_t i = 0; i < sizeof(raw_tx); i++) {
        buffer_t buf = {.ptr = raw_tx, .size = i, .offset = 0};
        parser_status_e status = transaction_deserialise_common(&buf, &tx);

        assert_int_equal(status, WRONG_LENGTH_ERROR);
    }

    buffer_t buf1 = {.ptr = raw_tx, .size = sizeof(raw_tx), .offset = 0};
    buffer_t buf2 = {.ptr = wrong_start_byte, .size = sizeof(wrong_start_byte), .offset = 0};
    buffer_t buf3 = {.ptr = wrong_version, .size = sizeof(wrong_version), .offset = 0};
    buffer_t buf4 = {.ptr = wrong_network, .size = sizeof(wrong_network), .offset = 0};
    buffer_t buf5 = {.ptr = wrong_memo_length, .size = sizeof(wrong_memo_length), .offset = 0};
    buffer_t buf6 = {.ptr = wrong_memo_encoding, .size = sizeof(wrong_memo_encoding), .offset = 0};

    parser_status_e status = transaction_deserialise_common(&buf1, &tx);

    assert_int_equal(status, PARSING_OK);
    assert_int_equal(tx.typeGroup, 0x00000001);
    assert_int_equal(tx.type, 0x0000);
    assert_int_equal(tx.fee, 0x00001001);
    assert_int_equal(tx.memo_len, 0xf1);
    assert_ptr_equal(tx.sender_publickey, pkey_ptr);
    assert_int_equal(tx.memo, memo_ptr);

    memset(&status, 0, sizeof(status));

    status = transaction_deserialise_common(&buf2, &tx);

    assert_int_equal(status, STARTING_BYTE_PARSING_ERROR);

    memset(&status, 0, sizeof(status));

    status = transaction_deserialise_common(&buf3, &tx);

    assert_int_equal(status, VERSION_PARSING_ERROR);

    memset(&status, 0, sizeof(status));

    status = transaction_deserialise_common(&buf4, &tx);

    assert_int_equal(status, NETWORK_PARSING_ERROR);

    memset(&status, 0, sizeof(status));

    status = transaction_deserialise_common(&buf5, &tx);

    assert_int_equal(status, WRONG_LENGTH_ERROR);

    memset(&status, 0, sizeof(status));

    status = transaction_deserialise_common(&buf6, &tx);

    assert_int_equal(status, MEMO_ENCODING_ERROR);

}

static void test_tx_vote_serialization(void **state) {
    (void) state;

    transaction_asset_t tx;
    // clang-format off
    uint8_t core_asset[] = {
        // count (1)
        0x02,
        // length username 1 (1)
        0x0a,
        // bp username 1
        0x63, 0x61, 0x63, 0x74, 0x75, 0x73, 0x31, 0x35,
        0x34, 0x39,
        // percentage 1 (2)
        0x88, 0x13,
        // length username 2 (1)
        0x03,
        // bp username 2
        0x66, 0x75, 0x6E,
        // percentage 2 (2)
        0x88, 0x13
    };

    uint8_t *votes_ptr = (uint8_t *) core_asset + 1;

    uint8_t zero_count[] = {
        // count (1)
        0x00
    };

    uint8_t over_max_count[] = {
        // count (1)
        0xff
    };

    uint8_t wrong_count1[] = {
        // count (1)
        0x03,
        // length username 1 (1)
        0x0a,
        // bp username 1
        0x63, 0x61, 0x63, 0x74, 0x75, 0x73, 0x31, 0x35,
        0x34, 0x39,
        // percentage 1 (2)
        0x88, 0x13,
        // length username 2 (1)
        0x03,
        // bp username 2
        0x66, 0x75, 0x6E,
        // percentage 2 (2)
        0x88, 0x13
    };

    uint8_t wrong_count2[] = {
        // count (1)
        0x01,
         // length username 1 (1)
        0x0a,
        // bp username 1
        0x63, 0x61, 0x63, 0x74, 0x75, 0x73, 0x31, 0x35,
        0x34, 0x39,
        // percentage 1 (2)
        0x10, 0x27,
        // length username 2 (1)
        0x03,
        // bp username 2
        0x66, 0x75, 0x6E,
        // percentage 2 (2)
        0x88, 0x13
    };

    uint8_t username_length_exceed_max[] = {
        // count (1)
        0x01,
        // length username 1 (1)
        0x15,
        // bp username 1
        0x63, 0x61, 0x63, 0x74, 0x75, 0x73, 0x31, 0x35,
        0x34, 0x39, 0x63, 0x61, 0x63, 0x74, 0x75, 0x73,
        0x31, 0x35, 0x34, 0x39, 0x63,
        // percentage 1 (2)
        0x10, 0x27
    };

    uint8_t wrong_username_length[] = {
        // count (1)
        0x01,
        // length username 1 (1)
        0x0b,
        // bp username 1
        0x63, 0x61, 0x63, 0x74, 0x75, 0x73, 0x31, 0x35,
        0x34, 0x39,
        // percentage 1 (2)
        0x10, 0x27
    };

    uint8_t wrong_username_encoding[] = {
        // count (1)
        0x01,
        // length username 1 (1)
        0x0a,
        // bp username 1
        0x63, 0x61, 0x63, 0x74, 0x75, 0x73, 0x31, 0x35,
        0x34, 0x0a,
        // percentage 1 (2)
        0x10, 0x27
    };

    uint8_t percentage_sum_not_100[] = {
        // count (1)
        0x02,
        // length username 1 (1)
        0x0a,
        // bp username 1
        0x63, 0x61, 0x63, 0x74, 0x75, 0x73, 0x31, 0x35,
        0x34, 0x39,
        // percentage 1 (2)
        0x88, 0x13,
        // length username 2 (1)
        0x03,
        // bp username 2
        0x66, 0x75, 0x6E,
        // percentage 2 (2)
        0x88, 0x12
    };

    uint8_t zero_percentage[] = {
        // count (1)
        0x02,
        // length username 1 (1)
        0x0a,
        // bp username 1
        0x63, 0x61, 0x63, 0x74, 0x75, 0x73, 0x31, 0x35,
        0x34, 0x39,
        // percentage 1 (2)
        0x00, 0x00,
        // length username 2 (1)
        0x03,
        // bp username 2
        0x66, 0x75, 0x6E,
        // percentage 2 (2)
        0x10, 0x27
    };


    for (uint16_t i = 0; i < sizeof(core_asset); i++) {
        buffer_t buf = {.ptr = core_asset, .size = i, .offset = 0};
        parser_status_e status = transaction_deserialise_core_asset(&buf, &tx, 2, 2);

        assert_int_equal(status, WRONG_LENGTH_ERROR);
    }

    buffer_t buf1 = {.ptr = core_asset, .size = sizeof(core_asset), .offset = 0};
    buffer_t buf2 = {.ptr = zero_count, .size = sizeof(zero_count), .offset = 0};
    buffer_t buf3 = {.ptr = over_max_count, .size = sizeof(over_max_count), .offset = 0};
    buffer_t buf4 = {.ptr = percentage_sum_not_100, .size = sizeof(percentage_sum_not_100), .offset = 0};
    buffer_t buf5 = {.ptr = wrong_count1, .size = sizeof(wrong_count1), .offset = 0};
    buffer_t buf6 = {.ptr = wrong_count2, .size = sizeof(wrong_count2), .offset = 0};
    buffer_t buf7 = {.ptr = username_length_exceed_max, .size = sizeof(username_length_exceed_max), .offset = 0};
    buffer_t buf8 = {.ptr = zero_percentage, .size = sizeof(zero_percentage), .offset = 0};
    buffer_t buf9 = {.ptr = wrong_username_length, .size = sizeof(wrong_username_length), .offset = 0};
    buffer_t buf10 = {.ptr = wrong_username_encoding, .size = sizeof(wrong_username_encoding), .offset = 0};

    parser_status_e status = transaction_deserialise_core_asset(&buf1, &tx, 2, 2);

    assert_int_equal(status, PARSING_OK);
    assert_int_equal(tx.Vote.vote_length, 0x2);
    assert_ptr_equal(tx.Vote.votes, votes_ptr);

    memset(&status, 0, sizeof(status));

    status = transaction_deserialise_core_asset(&buf2, &tx, 2, 2);

    assert_int_equal(status, PARSING_OK);

    memset(&status, 0, sizeof(status));

    status = transaction_deserialise_core_asset(&buf3, &tx, 2, 2);

    assert_int_equal(status, CORE_ASSET_PARSING_ERROR);

    memset(&status, 0, sizeof(status));

    status = transaction_deserialise_core_asset(&buf4, &tx, 2, 2);

    assert_int_equal(status, CORE_ASSET_PARSING_ERROR);

    memset(&status, 0, sizeof(status));

    status = transaction_deserialise_core_asset(&buf5, &tx, 2, 2);

    assert_int_equal(status, WRONG_LENGTH_ERROR);

    memset(&status, 0, sizeof(status));

    status = transaction_deserialise_core_asset(&buf6, &tx, 2, 2);

    assert_int_equal(status, WRONG_LENGTH_ERROR);

    memset(&status, 0, sizeof(status));

    status = transaction_deserialise_core_asset(&buf7, &tx, 2, 2);

    assert_int_equal(status, CORE_ASSET_PARSING_ERROR);

    memset(&status, 0, sizeof(status));

    status = transaction_deserialise_core_asset(&buf8, &tx, 2, 2);

    assert_int_equal(status, CORE_ASSET_PARSING_ERROR);

    memset(&status, 0, sizeof(status));

    status = transaction_deserialise_core_asset(&buf9, &tx, 2, 2);

    assert_int_equal(status, CORE_ASSET_PARSING_ERROR);

    memset(&status, 0, sizeof(status));

    status = transaction_deserialise_core_asset(&buf10, &tx, 2, 2);

    assert_int_equal(status, CORE_ASSET_PARSING_ERROR);

}

static void test_tx_ipfs_serialization(void **state) {
    (void) state;

    transaction_asset_t tx;
    // clang-format off
    uint8_t core_asset[] = {
        // IPFS (variable length 2-64)
        0x12, 0x20, 0x40, 0xe8, 0xc8, 0xcc, 0x86, 0x49,
        0x3d, 0x35, 0xf0, 0x1b, 0x60, 0x31, 0x90, 0x49,
        0x9a, 0xd4, 0x04, 0x6c, 0xf2, 0xd0, 0x97, 0xf5,
        0xd3, 0x4d, 0xe0, 0x34, 0xce, 0xbb, 0xba, 0x90,
        0x48, 0x04
    };

    uint8_t *ipfs_ptr = (uint8_t *) core_asset;

    uint8_t zero_length[] = {
        // IPFS (variable length 2-64)
        0x12, 0x00
    };

    uint8_t too_long[] = {
        // IPFS (variable length 2-64)
        0x12, 0x42, 0x40, 0xe8, 0xc8, 0xcc, 0x86, 0x49,
        0x3d, 0x35, 0xf0, 0x1b, 0x60, 0x31, 0x90, 0x49,
        0x9a, 0xd4, 0x04, 0x6c, 0xf2, 0xd0, 0x97, 0xf5,
        0xd3, 0x4d, 0xe0, 0x34, 0xce, 0xbb, 0xba, 0x90,
        0xd3, 0x4d, 0xe0, 0x34, 0xce, 0xbb, 0xba, 0x90,
        0xd3, 0x4d, 0xe0, 0x34, 0xce, 0xbb, 0xba, 0x90,
        0xd3, 0x4d, 0xe0, 0x34, 0xce, 0xbb, 0xba, 0x90,
        0xd3, 0x4d, 0xe0, 0x34, 0xce, 0xbb, 0xba, 0x90,
        0xd3, 0x4d, 0xe0
    };

    uint8_t wrong_count1[] = {
        // IPFS (variable length 2-64)
        0x12, 0x03, 0x40, 0xe8
    };

    uint8_t wrong_count2[] = {
        // IPFS (variable length 2-64)
        0x12, 0x03, 0x40, 0xe8, 0xc8, 0xcc
    };

    for (uint16_t i = 0; i < sizeof(core_asset); i++) {
        buffer_t buf = {.ptr = core_asset, .size = i, .offset = 0};
        parser_status_e status = transaction_deserialise_core_asset(&buf, &tx, 5, 1);

        assert_int_equal(status, WRONG_LENGTH_ERROR);
    }

    buffer_t buf1 = {.ptr = core_asset, .size = sizeof(core_asset), .offset = 0};
    buffer_t buf2 = {.ptr = zero_length, .size = sizeof(zero_length), .offset = 0};
    buffer_t buf3 = {.ptr = too_long, .size = sizeof(too_long), .offset = 0};
    buffer_t buf4 = {.ptr = wrong_count1, .size = sizeof(wrong_count1), .offset = 0};
    buffer_t buf5 = {.ptr = wrong_count2, .size = sizeof(wrong_count2), .offset = 0};

    parser_status_e status = transaction_deserialise_core_asset(&buf1, &tx, 5, 1);

    assert_int_equal(status, PARSING_OK);
    assert_int_equal(tx.Ipfs.ipfs_length, 0x22);
    assert_ptr_equal(tx.Ipfs.ipfs, ipfs_ptr);

    memset(&status, 0, sizeof(status));

    status = transaction_deserialise_core_asset(&buf2, &tx, 5, 1);

    assert_int_equal(status, CORE_ASSET_PARSING_ERROR);

    memset(&status, 0, sizeof(status));

    status = transaction_deserialise_core_asset(&buf3, &tx, 5, 1);

    assert_int_equal(status, CORE_ASSET_PARSING_ERROR);

    memset(&status, 0, sizeof(status));

    status = transaction_deserialise_core_asset(&buf4, &tx, 5, 1);

    assert_int_equal(status, WRONG_LENGTH_ERROR);

    memset(&status, 0, sizeof(status));

    status = transaction_deserialise_core_asset(&buf5, &tx, 5, 1);

    assert_int_equal(status, WRONG_LENGTH_ERROR);

}

static void test_tx_transfer_serialization(void **state) {
    (void) state;

    transaction_asset_t tx;
    // clang-format off
    uint8_t core_asset[] = {
        // length (2)
        0x05, 0x00,
        // amount 1 (8)
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        // RecipientId 1 (21)
        0x3f, 0xc9, 0x13, 0x27, 0xb9, 0x17, 0xbf, 0x2b,
        0x46, 0x4e, 0x9b, 0x8f, 0x1a, 0xcf, 0x05, 0x88,
        0xf4, 0xcb, 0x6e, 0x7b, 0xb3,
        // amount 2 (8)
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        // RecipientId 2 (21)
        0x3f, 0xc9, 0x13, 0x27, 0xb9, 0x17, 0xbf, 0x2b,
        0x46, 0x4e, 0x9b, 0x8f, 0x1a, 0xcf, 0x05, 0x88,
        0xf4, 0xcb, 0x6e, 0x7b, 0xb3,
        // amount 3 (8)
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        // RecipientId 3 (21)
        0x3f, 0xc9, 0x13, 0x27, 0xb9, 0x17, 0xbf, 0x2b,
        0x46, 0x4e, 0x9b, 0x8f, 0x1a, 0xcf, 0x05, 0x88,
        0xf4, 0xcb, 0x6e, 0x7b, 0xb3,
        // amount 4 (8)
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        // RecipientId 4 (21)
        0x3f, 0xc9, 0x13, 0x27, 0xb9, 0x17, 0xbf, 0x2b,
        0x46, 0x4e, 0x9b, 0x8f, 0x1a, 0xcf, 0x05, 0x88,
        0xf4, 0xcb, 0x6e, 0x7b, 0xb3,
        // amount 5 (8)
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        // RecipientId 5 (21)
        0x3f, 0xc9, 0x13, 0x27, 0xb9, 0x17, 0xbf, 0x2b,
        0x46, 0x4e, 0x9b, 0x8f, 0x1a, 0xcf, 0x05, 0x88,
        0xf4, 0xcb, 0x6e, 0x7b, 0xb3,

    };

    uint8_t *transfers_ptr = (uint8_t *) core_asset + 2;

    uint8_t less_min[] = {
        // length (2)
        0x00, 0x00,
    };

    uint8_t over_max[] = {
        // length (2)
        0x29, 0x00,
        // amount 1 (8)
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xc9, 0x13, 0x27, 0xb9, 0x17, 0xbf, 0x2b,
        0x46, 0x4e, 0x9b, 0x8f, 0x1a, 0xcf, 0x05, 0x88, 0xf4, 0xcb, 0x6e, 0x7b, 0xb3, 0x01, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xc9, 0x13, 0x27, 0xb9, 0x17, 0xbf, 0x2b, 0x46, 0x4e, 0x9b,
        0x8f, 0x1a, 0xcf, 0x05, 0x88, 0xf4, 0xcb, 0x6e, 0x7b, 0xb3, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x17, 0xc9, 0x13, 0x27, 0xb9, 0x17, 0xbf, 0x2b, 0x46, 0x4e, 0x9b, 0x8f, 0x1a, 0xcf,
        0x05, 0x88, 0xf4, 0xcb, 0x6e, 0x7b, 0xb3, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17,
        0xc9, 0x13, 0x27, 0xb9, 0x17, 0xbf, 0x2b, 0x46, 0x4e, 0x9b, 0x8f, 0x1a, 0xcf, 0x05, 0x88, 0xf4,
        0xcb, 0x6e, 0x7b, 0xb3, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xc9, 0x13, 0x27,
        0xb9, 0x17, 0xbf, 0x2b, 0x46, 0x4e, 0x9b, 0x8f, 0x1a, 0xcf, 0x05, 0x88, 0xf4, 0xcb, 0x6e, 0x7b,
        0xb3, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xc9, 0x13, 0x27, 0xb9, 0x17, 0xbf,
        0x2b, 0x46, 0x4e, 0x9b, 0x8f, 0x1a, 0xcf, 0x05, 0x88, 0xf4, 0xcb, 0x6e, 0x7b, 0xb3, 0x01, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xc9, 0x13, 0x27, 0xb9, 0x17, 0xbf, 0x2b, 0x46, 0x4e,
        0x9b, 0x8f, 0x1a, 0xcf, 0x05, 0x88, 0xf4, 0xcb, 0x6e, 0x7b, 0xb3, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x17, 0xc9, 0x13, 0x27, 0xb9, 0x17, 0xbf, 0x2b, 0x46, 0x4e, 0x9b, 0x8f, 0x1a,
        0xcf, 0x05, 0x88, 0xf4, 0xcb, 0x6e, 0x7b, 0xb3, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x17, 0xc9, 0x13, 0x27, 0xb9, 0x17, 0xbf, 0x2b, 0x46, 0x4e, 0x9b, 0x8f, 0x1a, 0xcf, 0x05, 0x88,
        0xf4, 0xcb, 0x6e, 0x7b, 0xb3, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xc9, 0x13,
        0x27, 0xb9, 0x17, 0xbf, 0x2b, 0x46, 0x4e, 0x9b, 0x8f, 0x1a, 0xcf, 0x05, 0x88, 0xf4, 0xcb, 0x6e,
        0x7b, 0xb3, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xc9, 0x13, 0x27, 0xb9, 0x17,
        0xbf, 0x2b, 0x46, 0x4e, 0x9b, 0x8f, 0x1a, 0xcf, 0x05, 0x88, 0xf4, 0xcb, 0x6e, 0x7b, 0xb3, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xc9, 0x13, 0x27, 0xb9, 0x17, 0xbf, 0x2b, 0x46,
        0x4e, 0x9b, 0x8f, 0x1a, 0xcf, 0x05, 0x88, 0xf4, 0xcb, 0x6e, 0x7b, 0xb3, 0x01, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x17, 0xc9, 0x13, 0x27, 0xb9, 0x17, 0xbf, 0x2b, 0x46, 0x4e, 0x9b, 0x8f,
        0x1a, 0xcf, 0x05, 0x88, 0xf4, 0xcb, 0x6e, 0x7b, 0xb3, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x17, 0xc9, 0x13, 0x27, 0xb9, 0x17, 0xbf, 0x2b, 0x46, 0x4e, 0x9b, 0x8f, 0x1a, 0xcf, 0x05,
        0x88, 0xf4, 0xcb, 0x6e, 0x7b, 0xb3, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xc9,
        0x13, 0x27, 0xb9, 0x17, 0xbf, 0x2b, 0x46, 0x4e, 0x9b, 0x8f, 0x1a, 0xcf, 0x05, 0x88, 0xf4, 0xcb,
        0x6e, 0x7b, 0xb3, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xc9, 0x13, 0x27, 0xb9,
        0x17, 0xbf, 0x2b, 0x46, 0x4e, 0x9b, 0x8f, 0x1a, 0xcf, 0x05, 0x88, 0xf4, 0xcb, 0x6e, 0x7b, 0xb3,
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xc9, 0x13, 0x27, 0xb9, 0x17, 0xbf, 0x2b,
        0x46, 0x4e, 0x9b, 0x8f, 0x1a, 0xcf, 0x05, 0x88, 0xf4, 0xcb, 0x6e, 0x7b, 0xb3, 0x01, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xc9, 0x13, 0x27, 0xb9, 0x17, 0xbf, 0x2b, 0x46, 0x4e, 0x9b,
        0x8f, 0x1a, 0xcf, 0x05, 0x88, 0xf4, 0xcb, 0x6e, 0x7b, 0xb3, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x17, 0xc9, 0x13, 0x27, 0xb9, 0x17, 0xbf, 0x2b, 0x46, 0x4e, 0x9b, 0x8f, 0x1a, 0xcf,
        0x05, 0x88, 0xf4, 0xcb, 0x6e, 0x7b, 0xb3, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17,
        0xc9, 0x13, 0x27, 0xb9, 0x17, 0xbf, 0x2b, 0x46, 0x4e, 0x9b, 0x8f, 0x1a, 0xcf, 0x05, 0x88, 0xf4,
        0xcb, 0x6e, 0x7b, 0xb3, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xc9, 0x13, 0x27,
        0xb9, 0x17, 0xbf, 0x2b, 0x46, 0x4e, 0x9b, 0x8f, 0x1a, 0xcf, 0x05, 0x88, 0xf4, 0xcb, 0x6e, 0x7b,
        0xb3, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xc9, 0x13, 0x27, 0xb9, 0x17, 0xbf,
        0x2b, 0x46, 0x4e, 0x9b, 0x8f, 0x1a, 0xcf, 0x05, 0x88, 0xf4, 0xcb, 0x6e, 0x7b, 0xb3, 0x01, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xc9, 0x13, 0x27, 0xb9, 0x17, 0xbf, 0x2b, 0x46, 0x4e,
        0x9b, 0x8f, 0x1a, 0xcf, 0x05, 0x88, 0xf4, 0xcb, 0x6e, 0x7b, 0xb3, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x17, 0xc9, 0x13, 0x27, 0xb9, 0x17, 0xbf, 0x2b, 0x46, 0x4e, 0x9b, 0x8f, 0x1a,
        0xcf, 0x05, 0x88, 0xf4, 0xcb, 0x6e, 0x7b, 0xb3, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x17, 0xc9, 0x13, 0x27, 0xb9, 0x17, 0xbf, 0x2b, 0x46, 0x4e, 0x9b, 0x8f, 0x1a, 0xcf, 0x05, 0x88,
        0xf4, 0xcb, 0x6e, 0x7b, 0xb3, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xc9, 0x13,
        0x27, 0xb9, 0x17, 0xbf, 0x2b, 0x46, 0x4e, 0x9b, 0x8f, 0x1a, 0xcf, 0x05, 0x88, 0xf4, 0xcb, 0x6e,
        0x7b, 0xb3, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xc9, 0x13, 0x27, 0xb9, 0x17,
        0xbf, 0x2b, 0x46, 0x4e, 0x9b, 0x8f, 0x1a, 0xcf, 0x05, 0x88, 0xf4, 0xcb, 0x6e, 0x7b, 0xb3, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xc9, 0x13, 0x27, 0xb9, 0x17, 0xbf, 0x2b, 0x46,
        0x4e, 0x9b, 0x8f, 0x1a, 0xcf, 0x05, 0x88, 0xf4, 0xcb, 0x6e, 0x7b, 0xb3, 0x01, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x17, 0xc9, 0x13, 0x27, 0xb9, 0x17, 0xbf, 0x2b, 0x46, 0x4e, 0x9b, 0x8f,
        0x1a, 0xcf, 0x05, 0x88, 0xf4, 0xcb, 0x6e, 0x7b, 0xb3, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x17, 0xc9, 0x13, 0x27, 0xb9, 0x17, 0xbf, 0x2b, 0x46, 0x4e, 0x9b, 0x8f, 0x1a, 0xcf, 0x05,
        0x88, 0xf4, 0xcb, 0x6e, 0x7b, 0xb3, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xc9,
        0x13, 0x27, 0xb9, 0x17, 0xbf, 0x2b, 0x46, 0x4e, 0x9b, 0x8f, 0x1a, 0xcf, 0x05, 0x88, 0xf4, 0xcb,
        0x6e, 0x7b, 0xb3, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xc9, 0x13, 0x27, 0xb9,
        0x17, 0xbf, 0x2b, 0x46, 0x4e, 0x9b, 0x8f, 0x1a, 0xcf, 0x05, 0x88, 0xf4, 0xcb, 0x6e, 0x7b, 0xb3,
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xc9, 0x13, 0x27, 0xb9, 0x17, 0xbf, 0x2b,
        0x46, 0x4e, 0x9b, 0x8f, 0x1a, 0xcf, 0x05, 0x88, 0xf4, 0xcb, 0x6e, 0x7b, 0xb3, 0x01, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xc9, 0x13, 0x27, 0xb9, 0x17, 0xbf, 0x2b, 0x46, 0x4e, 0x9b,
        0x8f, 0x1a, 0xcf, 0x05, 0x88, 0xf4, 0xcb, 0x6e, 0x7b, 0xb3, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x17, 0xc9, 0x13, 0x27, 0xb9, 0x17, 0xbf, 0x2b, 0x46, 0x4e, 0x9b, 0x8f, 0x1a, 0xcf,
        0x05, 0x88, 0xf4, 0xcb, 0x6e, 0x7b, 0xb3, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17,
        0xc9, 0x13, 0x27, 0xb9, 0x17, 0xbf, 0x2b, 0x46, 0x4e, 0x9b, 0x8f, 0x1a, 0xcf, 0x05, 0x88, 0xf4,
        0xcb, 0x6e, 0x7b, 0xb3, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xc9, 0x13, 0x27,
        0xb9, 0x17, 0xbf, 0x2b, 0x46, 0x4e, 0x9b, 0x8f, 0x1a, 0xcf, 0x05, 0x88, 0xf4, 0xcb, 0x6e, 0x7b,
        0xb3, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xc9, 0x13, 0x27, 0xb9, 0x17, 0xbf,
        0x2b, 0x46, 0x4e, 0x9b, 0x8f, 0x1a, 0xcf, 0x05, 0x88, 0xf4, 0xcb, 0x6e, 0x7b, 0xb3, 0x01, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xc9, 0x13, 0x27, 0xb9, 0x17, 0xbf, 0x2b, 0x46, 0x4e,
        0x9b, 0x8f, 0x1a, 0xcf, 0x05, 0x88, 0xf4, 0xcb, 0x6e, 0x7b, 0xb3, 0x01, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x17, 0xc9, 0x13, 0x27, 0xb9, 0x17, 0xbf, 0x2b, 0x46, 0x4e, 0x9b, 0x8f, 0x1a,
        0xcf, 0x05, 0x88, 0xf4, 0xcb, 0x6e, 0x7b, 0xb3, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x17, 0xc9, 0x13, 0x27, 0xb9, 0x17, 0xbf, 0x2b, 0x46, 0x4e, 0x9b, 0x8f, 0x1a, 0xcf, 0x05, 0x88,
        0xf4, 0xcb, 0x6e, 0x7b, 0xb3
    };

    uint8_t wrong_count1[] = {
        // length (2)
        0x03, 0x00,
        // amount 1 (8)
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        // RecipientId 1 (21)
        0x3f, 0xc9, 0x13, 0x27, 0xb9, 0x17, 0xbf, 0x2b,
        0x46, 0x4e, 0x9b, 0x8f, 0x1a, 0xcf, 0x05, 0x88,
        0xf4, 0xcb, 0x6e, 0x7b, 0xb3,
        // amount 2 (8)
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        // RecipientId 2 (21)
        0x3f, 0xc9, 0x13, 0x27, 0xb9, 0x17, 0xbf, 0x2b,
        0x46, 0x4e, 0x9b, 0x8f, 0x1a, 0xcf, 0x05, 0x88,
        0xf4, 0xcb, 0x6e, 0x7b, 0xb3
    };

    uint8_t wrong_count2[] = {
        // length (2)
        0x03, 0x00,
        // amount 1 (8)
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        // RecipientId 1 (21)
        0x3f, 0xc9, 0x13, 0x27, 0xb9, 0x17, 0xbf, 0x2b,
        0x46, 0x4e, 0x9b, 0x8f, 0x1a, 0xcf, 0x05, 0x88,
        0xf4, 0xcb, 0x6e, 0x7b, 0xb3,
        // amount 2 (8)
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        // RecipientId 2 (21)
        0x3f, 0xc9, 0x13, 0x27, 0xb9, 0x17, 0xbf, 0x2b,
        0x46, 0x4e, 0x9b, 0x8f, 0x1a, 0xcf, 0x05, 0x88,
        0xf4, 0xcb, 0x6e, 0x7b, 0xb3,
        // amount 3 (8)
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        // RecipientId 3 (21)
        0x3f, 0xc9, 0x13, 0x27, 0xb9, 0x17, 0xbf, 0x2b,
        0x46, 0x4e, 0x9b, 0x8f, 0x1a, 0xcf, 0x05, 0x88,
        0xf4, 0xcb, 0x6e, 0x7b, 0xb3,
        // amount 4 (8)
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        // RecipientId 4 (21)
        0x3f, 0xc9, 0x13, 0x27, 0xb9, 0x17, 0xbf, 0x2b,
        0x46, 0x4e, 0x9b, 0x8f, 0x1a, 0xcf, 0x05, 0x88,
        0xf4, 0xcb, 0x6e, 0x7b, 0xb3
    };

    for (uint16_t i = 0; i < sizeof(core_asset); i++) {
        buffer_t buf = {.ptr = core_asset, .size = i, .offset = 0};
        parser_status_e status = transaction_deserialise_core_asset(&buf, &tx, 6, 1);

        assert_int_equal(status, WRONG_LENGTH_ERROR);
    }

    buffer_t buf1 = {.ptr = core_asset, .size = sizeof(core_asset), .offset = 0};
    buffer_t buf2 = {.ptr = less_min, .size = sizeof(less_min), .offset = 0};
    buffer_t buf3 = {.ptr = over_max, .size = sizeof(over_max), .offset = 0};
    buffer_t buf4 = {.ptr = wrong_count1, .size = sizeof(wrong_count1), .offset = 0};
    buffer_t buf5 = {.ptr = wrong_count2, .size = sizeof(wrong_count2), .offset = 0};

    parser_status_e status = transaction_deserialise_core_asset(&buf1, &tx, 6, 1);

    assert_int_equal(status, PARSING_OK);
    assert_int_equal(tx.Transfer.transfers_length, 0x5);
    assert_ptr_equal(tx.Transfer.transfers, transfers_ptr);

    memset(&status, 0, sizeof(status));

    status = transaction_deserialise_core_asset(&buf2, &tx, 6, 1);

    assert_int_equal(status, CORE_ASSET_PARSING_ERROR);

    memset(&status, 0, sizeof(status));

    status = transaction_deserialise_core_asset(&buf3, &tx, 6, 1);

    assert_int_equal(status, CORE_ASSET_PARSING_ERROR);

    memset(&status, 0, sizeof(status));

    status = transaction_deserialise_core_asset(&buf4, &tx, 6, 1);

    assert_int_equal(status, WRONG_LENGTH_ERROR);

    memset(&status, 0, sizeof(status));

    status = transaction_deserialise_core_asset(&buf5, &tx, 6, 1);

    assert_int_equal(status, WRONG_LENGTH_ERROR);

}

static void test_tx_burn_serialization(void **state) {
    (void) state;

    transaction_asset_t tx;
    // clang-format off
    uint8_t core_asset[] = {
        // amount (8)
        0x01, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00
    };

    uint8_t missing_amount_byte[] = {
        // amount (8)
        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x00
    };

    for (uint16_t i = 0; i < sizeof(core_asset); i++) {
        buffer_t buf = {.ptr = core_asset, .size = i, .offset = 0};
        parser_status_e status = transaction_deserialise_core_asset(&buf, &tx, 0, 2);

        assert_int_equal(status, WRONG_LENGTH_ERROR);
    }

    buffer_t buf1 = {.ptr = core_asset, .size = sizeof(core_asset), .offset = 0};
    buffer_t buf2 = {.ptr = missing_amount_byte, .size = sizeof(missing_amount_byte), .offset = 0};

    parser_status_e status = transaction_deserialise_core_asset(&buf1, &tx, 0, 2);

    assert_int_equal(status, PARSING_OK);
    assert_int_equal(tx.Burn.amount, 0x2000001);

    memset(&status, 0, sizeof(status));

    status = transaction_deserialise_core_asset(&buf2, &tx, 0, 2);

    assert_int_equal(status, WRONG_LENGTH_ERROR);

}

static void test_wrong_type(void **state) {
    (void) state;

    transaction_asset_t tx;
    // clang-format off
    uint8_t core_asset[] = {
        0x00
    };

    buffer_t buf = {.ptr = core_asset, .size = sizeof(core_asset), .offset = 0};

    parser_status_e status = transaction_deserialise_core_asset(&buf, &tx, 13, 1);

    assert_int_equal(status, TYPE_PARSING_ERROR);

    memset(&status, 0, sizeof(status));

    status = transaction_deserialise_core_asset(&buf, &tx, 3, 2);

    assert_int_equal(status, TYPE_PARSING_ERROR);

}

static void test_wrong_typegroup(void **state) {
    (void) state;

    transaction_asset_t tx;
    // clang-format off
    uint8_t core_asset[] = {
        0x00
    };

    buffer_t buf = {.ptr = core_asset, .size = sizeof(core_asset), .offset = 0};

    parser_status_e status = transaction_deserialise_core_asset(&buf, &tx, 0, 3);

    assert_int_equal(status, TYPE_PARSING_ERROR);

}

static void test_message_serialization(void **state) {
    (void) state;

    transaction_t tx;
    // clang-format off
    uint8_t valid_message[] = {
        0x07, 0x00, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,
        // Messages require to be 1 byte shorter than his buffer
        // to allow space for the null byte
        // This byte will be replaced by the null byte
        0xff
    };

    uint8_t *message_ptr = (uint8_t *) valid_message + 2;

    uint8_t not_ascii_message[] = {
        0x07, 0x00, 0x63, 0x63, 0x12, 0x63, 0x63, 0x63, 0x63,
        // This byte will be replaced by the null byte
        0xff
    };

    uint8_t empty_message[] = {
        0x00, 0x00,
        // This byte will be replaced by the null byte
        0xff
    };

    uint8_t wrong_length1[] = {
        0x05, 0x00, 0x63, 0x63, 0x63, 0x63,
        // This byte will be replaced by the null byte
        0xff
    };

    uint8_t wrong_length2[] = {
        0x05, 0x00, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,
        // This byte will be replaced by the null byte
        0xff
    };

    buffer_t buf1 = {.ptr = valid_message, .size = sizeof(valid_message) - 1, .offset = 0};
    buffer_t buf2 = {.ptr = not_ascii_message, .size = sizeof(not_ascii_message) - 1, .offset = 0};
    buffer_t buf3 = {.ptr = empty_message, .size = sizeof(empty_message) - 1, .offset = 0};
    buffer_t buf4 = {.ptr = wrong_length1, .size = sizeof(wrong_length1) - 1, .offset = 0};
    buffer_t buf5 = {.ptr = wrong_length2, .size = sizeof(wrong_length2) - 1, .offset = 0};

    parser_status_e status = message_deserialise(&buf1, &tx);

    assert_int_equal(status, PARSING_OK);
    assert_int_equal(tx.message_length, 0x7);
    assert_ptr_equal(tx.message, message_ptr);

    memset(&status, 0, sizeof(status));

    status = message_deserialise(&buf2, &tx);

    assert_int_equal(status, MESSAGE_ENCODING_ERROR);

    memset(&status, 0, sizeof(status));

    status = message_deserialise(&buf3, &tx);

    assert_int_equal(status, WRONG_LENGTH_ERROR);

    memset(&status, 0, sizeof(status));

    status = message_deserialise(&buf4, &tx);

    assert_int_equal(status, WRONG_LENGTH_ERROR);

    memset(&status, 0, sizeof(status));

    status = message_deserialise(&buf5, &tx);

    assert_int_equal(status, WRONG_LENGTH_ERROR);

}


int main() {
    const struct CMUnitTest tests[] = {cmocka_unit_test(test_tx_sample_serialization),
                                       cmocka_unit_test(test_tx_common_serialization),
                                       cmocka_unit_test(test_tx_transfer_serialization),
                                       cmocka_unit_test(test_tx_vote_serialization),
                                       cmocka_unit_test(test_tx_ipfs_serialization),
                                       cmocka_unit_test(test_tx_burn_serialization),
                                       cmocka_unit_test(test_wrong_type),
                                       cmocka_unit_test(test_wrong_typegroup),
                                       cmocka_unit_test(test_message_serialization)};

    return cmocka_run_group_tests(tests, NULL, NULL);
}
